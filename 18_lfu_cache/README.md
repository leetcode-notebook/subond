## LFU缓存

LFU 是 Least Frequently Used 的缩写，即最不经常、最少使用，也是一种常见缓存淘汰机制，选择访问计数器最小的页面进行淘汰。

所以，对每个缓存数据都带有一个访问计数器。



根据 LFU 的策略，每访问一次都需要更新该数据的访问计数器，并把数据移到访问计数器从大到小的位置。

举个例子，一个容量为 3 个缓存器，当前缓存器中的数据及其计数器分别是：

```sh
数据 A 计数器为23
数据 B 计数器为12
数据 C 计数器为12
```

插入数据 B，发现缓存中有 B，那么 B 的计数器加1，并移到按数据计数器排序的位置；

插入数据 D，发现缓存中没有 B，插入 D 将导致容量超过，那么计数器为12的数据 C，会被淘汰；数据 D 放在数据 B 的后面，计数器为1。

此时，缓存器中的数据及其计数器分别是：

```sh
数据 A 计数器为23
数据 B 计数器为13
数据 D 计数器为1
```



这里有一个 LRU 特别的地方。如果淘汰的数据有多个相同的计数器，那么选择最靠近尾部的数据，即从尾部删除。

![image](images/lfu_cache.png)

比如上图中数据 A、B、C的访问次数相同，都是 1，新插入的数据 F 不在缓存中，那么要淘汰 A，并把 F 放到数据 C 的前面。也就是说**相同访问次数，按照新旧顺序排列，淘汰最旧的数据。**

所以，可见**LFU 更新和插入可以发生在链表的任意位置，删除都发生在表尾。**



同样的，LFU 同样要求查询尽量高效，`O(1)`查询。那么，我们可以选择 map 辅助查询，选用双向链表存储 key-value。因为，LFU 需要记录访问次数，所以每个节点除了存储key, value，还要存储 frequency 访问次数。



### 如何按频次排序？

前面讲到过，相同频次的数据按先后时间排序。那么不同频次的数据，如何排序呢？

如果你开始考虑排序算法，那么你的思考方向就偏离了最佳答案。排序至少`O(logN)`。

回过头来看 LFU 的原理，你会发现它**只关心最小频次，其他频次之间的顺序不需要排序。**

因为，数据存在的时候，直接更新频次就好；只有数据不存在，新插入数据导致旧数据删除的时候，才会看数据的频次，且只看最小频次的数据。



我们可以选择 min 变量保存最小频次，淘汰时读取这个值找到要删除的数据。

相同频次的数据，按先后顺序排序，这个特点双向表插入动作已经体现了。





### 总结

总结下，LFU 是由两个 map 和一个 min 变量组成的数据结构。

一个 map 的 key 存储的是访问次数，对应的 value 是一个个双向链表，双向链表的作用是在相同频次的情况下，淘汰删除表尾的数据；而数据更新（或者新建）则从表头插入。

另一个 map 中 key 对应的 value 就是双向链表的节点，即实际存储的缓存数据。这里的双向链表节点比 LRU 多储存了一个访问次数的值，即 key-value-frequency 元组。

这里的双向链表的作用与 LRU 类似，既可以根据 map 中 key 更新双向链表节点的 value 和 frequency，也可以根据双向链表节点中的 key 和 frequency 反向更新 map 中的对应关系。
