## 480 滑动窗口中位数

题目要求：

中位数是有序序列中最中间的那个数。如果序列长度为偶数，那么则是最中间两个数的平均数。

给定一个数组 `nums` 和 整数 `k`，`k` 表示滑动窗口大小，从最左边滑动到最右边，每次窗口向右移动1位，请你找出滑动窗口中的中位数。

题目链接：https://leetcode.cn/problems/sliding-window-median/



算法：

这个题目还是滑动窗口的思想，需要注意的是窗口中的元素是无序，如果形成窗口之后在进行排序，会超时，因此在构造窗口的时候保证窗口内元素有序。

所以可以简单设计一个 `list` 结构，采用插入排序的思想，进行增加和删除操作。

```go
// list 实现
type (
	list struct {
		data []int
	}
)

func (l *list) add(x int) {
	// 先添加0元素，扩充数组; 再将x通过插入排序放到合适的位置
	n := len(l.data)
	l.data = append(l.data, 0)
	i := n-1	
	for i >= 0 {
		if x >= l.data[i] {
			l.data[i+1] = x
			return
		} else {
			l.data[i+1] = l.data[i]
		}
		i--	
	}
	l.data[i+1] = x
}

func (l *list) del(x int) {
	n := len(l.data)
	i := 0
	for i < n {
		if x == l.data[i] {
			copy(l.data[i:], l.data[i+1:])
      break
		}
		i++
	}
	l.data = l.data[:n-1]
}

func (l *list) find(once bool, step int) float64 {
	if once {
		return float64(l.data[step])
	}
	return (float64(l.data[step-1]) + float64(l.data[step])) / 2.0
}
```

主逻辑就是滑动窗口思想，如下：

```go
// date 2022/09/20
func medianSlidingWindow(nums []int, k int) []float64 {
    left, right := 0, 0
    ans := make([]float64, 0, 64)
    // 提前计算中位数是为了在find中减少计算，因为中位数只跟k有关
    // once表示中位数有1个还是2个
    once := false
    if k & 0x1  == 0x1 {
        once = true
    }
    step := k >> 1  //中位数的下标
    lt := &list{data: make([]int, 0, 64)}
    // 构造窗口
    for right < len(nums) {
        // 增加right，扩大窗口
        lt.add(nums[right])
        right++
        if right - left >= k {
            // 已经形成窗口，查找结果，增加left
            ans = append(ans, lt.find(once, step))
            lt.del(nums[left])
            left++
        }
    }

    return ans
}
```

