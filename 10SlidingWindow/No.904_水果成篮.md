## 904 水果成篮-中等

题目：

你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 `fruits` 表示，其中 `fruits[i]` 是第 `i` 棵树上的水果 **种类** 。

你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：

- 你只有 **两个** 篮子，并且每个篮子只能装 **单一类型** 的水果。每个篮子能够装的水果总量没有限制。
- 你可以选择任意一棵树开始采摘，你必须从 **每棵** 树（包括开始采摘的树）上 **恰好摘一个水果** 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。
- 一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。

给你一个整数数组 `fruits` ，返回你可以收集的水果的 **最大** 数目。



分析：

该题目重在理解题目。

1. Fruits 数组中的元素，代表水果的种类编号，即同一个编号表示同一种水果
2. 你只可采摘两种类型的水果，即子数组中不同的元素个数不能超过两个

所以，这道题就变成了求子数组中连续元素种类不超过2的最大长度。



滑动窗口算法。

1. 通过 map 维护元素的种类，一旦种类超过两种，那么左指针就要移动，直到元素移除，map 不超过两种为止
2. 那么，此时左右指针的距离就是子数组的长度，求最大子数组长度

```go
// date 2023/11/21
func totalFruit(fruits []int) int {
    var ans int
    set := make(map[int]int, 16)
    left := 0
    for right, v := range fruits {
        set[v]++
      	// 一旦超过两种，则缩小
        for len(set) > 2 {
            y := fruits[left]
            set[y]--
            if set[y] == 0 {
                delete(set, y)
            }
            left++
        }
        if right - left + 1 > ans {
            ans = right - left + 1
        }
    }
    return ans
}
```

