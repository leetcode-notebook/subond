## 310 最小高度树-中等

题目：

树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，一个任何没有简单环路的连通图都是一棵树。

给你一棵包含 `n` 个节点的树，标记为 `0` 到 `n - 1` 。给定数字 `n` 和一个有 `n - 1` 条无向边的 `edges` 列表（每一个边都是一对标签），其中 `edges[i] = [ai, bi]` 表示树中节点 `ai` 和 `bi` 之间存在一条无向边。

可选择树中任何一个节点作为根。当选择节点 `x` 作为根节点时，设结果树的高度为 `h` 。在所有可能的树中，具有最小高度的树（即，`min(h)`）被称为 **最小高度树** 。

请你找到所有的 **最小高度树** 并按 **任意顺序** 返回它们的根节点标签列表。

树的 **高度** 是指根节点和叶子节点之间最长向下路径上边的数量。



> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2020/09/01/e1.jpg)
>
> ```
> 输入：n = 4, edges = [[1,0],[1,2],[1,3]]
> 输出：[1]
> 解释：如图所示，当根是标签为 1 的节点时，树的高度是 1 ，这是唯一的最小高度树。
> ```
>
> **示例 2：**
>
> ![img](https://assets.leetcode.com/uploads/2020/09/01/e2.jpg)
>
> ```
> 输入：n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]
> 输出：[3,4]
> ```



分析：

这道题中所有的节点构成了一个无向图，那么想要求得最小高度树，其实就是求整个图中最长的那条路径上中间的一个或两个点。

如果最长路径的节点树为偶数，那么就是最中间的2个点。

如果最长路径的节点数为奇数，那么就是最中间的1个点。

怎么求最长路径呢？

可以这样考虑，整个图，所有最外层节点的度为1，把度为1的节点去掉，同时将其连接的节点的度减一，不断第重复这个过程，直到度为1的序列中节点数不超过2个。

这个过程其实就是拓扑排序的变形，从外向里搜索，也是 DFS。

```go
// date 2024/01/02
func findMinHeightTrees(n int, edges [][]int) []int {
    if n == 1 {
        return []int{0}
    }
    // 计算每个节点的度
    deg := make([]int, n)
    out := make([][]int, n)
    for _, v := range edges {
        out[v[0]] = append(out[v[0]], v[1])
        out[v[1]] = append(out[v[1]], v[0])
        deg[v[0]]++
        deg[v[1]]++
    }

    // 所有度为 1 的都在最外层
    // 拓扑排序，直到序列中的节点不超过两个，即最中心的两个
    queue := make([]int, 0, 16)
    for i, v := range deg {
        if v == 1 {
            queue = append(queue, i)
        }
    }

    remainNode := n
    for remainNode > 2 {
        x1 := len(queue)
        remainNode -= x1

        for _, cur := range queue {
            for _, v := range out[cur] {
                deg[v]--
                if deg[v] == 1 {
                    queue = append(queue, v)
                }
            }
        }

        queue = queue[x1:]
    }

    return queue
}
```

