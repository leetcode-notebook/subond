## 104二叉树的最大深度-简单

> 给定一个二叉树，找出其最大深度。
>
> 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
>
> **说明:** 叶子节点是指没有子节点的节点。



算法分析：

算法1：递归

```go
// 算法一: 递归，采用自底向上的递归思想
// 时间复杂度O(N)，空间复杂度O(NlogN)
// 自底向上的递归
func maxDepth(root *TreeNode) int {
    if root == nil {
        return 0
    }
    l, r := maxDepth(root.Left), maxDepth(root.Right)
    if l > r {
        return l+1
    }
    return r+1
}
```



算法2：dfs深度优先搜索

```go

// 算法三 dfs深度优先搜索
// 时间复杂度O(N)，空间复杂度O(NlogN)
// 自顶向下的递归
func maxDepth(root *TreeNode) int {
    // dfs
    var dfs func(root *TreeNode, level int) int
    dfs = func(root *TreeNode, level int) int {
        if root == nil { return level }
        if root.Left == nil && root.Right == nil { return level+1 }
        if root.Left == nil {
            return dfs(root.Right, level+1)
        }
        if root.Right == nil {
            return dfs(root.Left, level+1)
        }
        l, r := dfs(root.Left, level+1), dfs(root.Right, level+1)
        if l > r { return l }
        return r
    }
    return dfs(root, 0)
}
```



算法3：bfs广度优先搜索

```go
// 算法3
// bfs广度优先搜索
// 时间复杂度O(N)，空间复杂度O(N)
func maxDepth(root *TreeNode) int {
  if root == nil {return 0}
  queue := make([]*TreeNode, 0)
  queue = append(queue, root)
  depth, n := 0, 0
  for len(queue) != 0 {
    n = len(queue)
    for i := 0; i < n; i++ {
      if queue[i].Left != nil {
        queue = append(queue, queue[i].Left)
      }
      if queue[i].Right != nil {
        queue = append(queue, queue[i].Right)
      }
    }
    queue = queue[n:]
    depth++
  }
  return depth
}
```

