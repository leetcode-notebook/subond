#### 169 多数元素【Easy】

题目要求：https://leetcode-cn.com/problems/majority-element/

思路分析：

```go
// date 2020/03/18
// 算法1,两层循环
// 时间复杂度O(N^2),空间复杂度O(1)
func majorityElement(nums []int) int {
    n, c := len(nums), 1
    for i := 0; i < n; i++ {
        c = 1
        for j := i+1; j < n; j++ {
            if nums[i] == nums[j] {
                c++
            }
        }
        if n & 0x1 == 0 && c >= n >> 1 { return nums[i] }
        if n & 0x1 == 1 && c >= n >> 1 + 1 { return nums[i] }
    }
    return 0
}
// 算法2：利用map，空间换时间
// 时间复杂度O(N), 空间复杂度O(N); 题目中说明答案一定存在，所以空间复杂度可以是O(N/2)
func majorityElement(nums []int) int {
    set := make(map[int]int, len(nums) >> 1)
    for _, v := range nums {
        if _, ok := set[v]; ok {
            set[v]++
        } else {
            set[v] = 1
        }
        if len(nums) & 0x1 == 1 && set[v] > len(nums) >> 1 { return v }
        if len(nums) & 0x1 == 0 && set[v] >= len(nums) >> 1 { return v }
    }
    return -1
}
// 算法3：对数组排序，返回中间元素
// 时间复杂度O(NlogN)
func majorityElement(nums []int) int {
    sort.Slice(nums, func(i, j int) bool {
        return nums[i] < nums[j]
    })
    return nums[len(nums)>>1]
}
```

