## 496 下一个更大元素1-简单

题目：

`nums1` 中数字 `x` 的 **下一个更大元素** 是指 `x` 在 `nums2` 中对应位置 **右侧** 的 **第一个** 比 `x` 大的元素。

给你两个 **没有重复元素** 的数组 `nums1` 和 `nums2` ，下标从 **0** 开始计数，其中`nums1` 是 `nums2` 的子集。

对于每个 `0 <= i < nums1.length` ，找出满足 `nums1[i] == nums2[j]` 的下标 `j` ，并且在 `nums2` 确定 `nums2[j]` 的 **下一个更大元素** 。如果不存在下一个更大元素，那么本次查询的答案是 `-1` 。

返回一个长度为 `nums1.length` 的数组 `ans` 作为答案，满足 `ans[i]` 是如上所述的 **下一个更大元素** 。



> **示例 1：**
>
> ```
> 输入：nums1 = [4,1,2], nums2 = [1,3,4,2].
> 输出：[-1,3,-1]
> 解释：nums1 中每个值的下一个更大元素如下所述：
> - 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。
> - 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。
> - 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums1 = [2,4], nums2 = [1,2,3,4].
> 输出：[3,-1]
> 解释：nums1 中每个值的下一个更大元素如下所述：
> - 2 ，用加粗斜体标识，nums2 = [1,2,3,4]。下一个更大元素是 3 。
> - 4 ，用加粗斜体标识，nums2 = [1,2,3,4]。不存在下一个更大元素，所以答案是 -1 。
> ```





分析：

下一个更大的元素是指右侧第一个比 x 大的元素，所以可以逆序遍历，使用单调栈保存下一个更大的元素。

遍历的时候，如果单调栈不为空，依次弹出栈顶元素。

此后，如果栈不为空，那么栈顶元素就是下一个更大的元素，否则就是 -1。

因为题目中表明数组的中的元素互不相同，可用 map 存储结果，方便 num1 检索。

```go
// date 2023/12/18
func nextGreaterElement(nums1 []int, nums2 []int) []int {
    set := make(map[int]int, 16)

    // 寻找右侧 第一个 比 x 大的元素
    // 逆序遍历，单调栈保存右侧第一个比x大的元素
    stack := make([]int, 0, 16)
    for i := len(nums2)-1; i >= 0; i-- {
        v := nums2[i]
        for len(stack) > 0 && v >= stack[len(stack)-1] {
            stack = stack[:len(stack)-1]
        }
        if len(stack) == 0 {
            set[v] = -1
        } else {
            set[v] = stack[len(stack)-1]
        }
        stack = append(stack, v)
    }
    ans := make([]int, len(nums1))
    for i, v1 := range nums1 {
        res, ok := set[v1]
        if ok {
            ans[i] = res
        } else {
            ans[i] = -1
        }
    }

    return ans
}
```

