## 456 132模式-中等

题目：

给你一个整数数组 `nums` ，数组中共有 `n` 个整数。**132 模式的子序列** 由三个整数 `nums[i]`、`nums[j]` 和 `nums[k]` 组成，并同时满足：`i < j < k` 和 `nums[i] < nums[k] < nums[j]` 。

如果 `nums` 中存在 **132 模式的子序列** ，返回 `true` ；否则，返回 `false` 。



> **示例 1：**
>
> ```
> 输入：nums = [1,2,3,4]
> 输出：false
> 解释：序列中不存在 132 模式的子序列。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [3,1,4,2]
> 输出：true
> 解释：序列中有 1 个 132 模式的子序列： [1, 4, 2] 。
> ```
>
> **示例 3：**
>
> ```
> 输入：nums = [-1,3,2,0]
> 输出：true
> 解释：序列中有 3 个 132 模式的的子序列：[-1, 3, 2]、[-1, 3, 0] 和 [-1, 2, 0] 。
> ```



分析：

这道题可以这样想，先说 123 模式。什么是 123 模式呢？就是简单的单调递增数组。

判断一个数组是不是单调递增有两种方式：

方式1，从前向后遍历，检查每个元素是不是比前一个元素更大。

方式2，从后往前遍历，检查每个元素是不是比后一个元素更小。

在方式2的基础上，把遍历元素依次入栈，那么就是单调递减栈。

单调递减栈，即栈顶小于栈底。

```sh
// 栈底 -- 栈顶
// 4,3,2,1
```

其次，还要叠加从后往前遍历数组，如果 stack 的顺序是我们期望的`4,3,2,1`，那么说明我们已经遍历过的部分数组是单调递增的。

此时，如果有元素打破了这里的单调递减栈，则说明更靠近数组头部的元素出现了较大的值，即我们要找的 `j`出现了，索引在中间，但值更大。

此时，把栈中较小的值依次出栈，保存在 num3 中， 即我们要找的 k，而且，ak 是小于aj里面最大的那个。

那么，再接着往前遍历，只要出现比 ak 还小的元素，那么 132 就成立了。

```go
// date 2023/12/20
func find132pattern(nums []int) bool {
    if len(nums) < 3 {
        return false
    }
    // i < j < k
    // ai < ak < aj
    num3 := math.MinInt64
    stack := make([]int, 0, 16)
    for i := len(nums)-1; i >= 0; i-- {
        v := nums[i]
        if v < num3 {
            return true
        }
        // if v > stack[len(stack)-1], so v is aj
        for len(stack) > 0 && v > stack[len(stack)-1] {
            // save the smmal to num3, num3 is ak
            num3 = stack[len(stack)-1]
            stack = stack[:len(stack)-1]
        }
        stack = append(stack, v)
    }
    return false
}
```

